<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Netty之NioEventLoop流程简单分析</title>
      <link href="/2020/02/19/Netty%E4%B9%8BNioEventLoop%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/"/>
      <url>/2020/02/19/Netty%E4%B9%8BNioEventLoop%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h4 id="Netty之NioEventLoop流程简单分析（4-1-30-Final-SNAPSHOT）"><a href="#Netty之NioEventLoop流程简单分析（4-1-30-Final-SNAPSHOT）" class="headerlink" title="Netty之NioEventLoop流程简单分析（4.1.30.Final-SNAPSHOT）"></a>Netty之NioEventLoop流程简单分析（4.1.30.Final-SNAPSHOT）</h4><pre class=" language-java"><code class="language-java">NioEventLoop类核心代码块<span class="token operator">:</span><span class="token annotation punctuation">@Override</span><span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token keyword">switch</span> <span class="token punctuation">(</span>selectStrategy<span class="token punctuation">.</span><span class="token function">calculateStrategy</span><span class="token punctuation">(</span>selectNowSupplier<span class="token punctuation">,</span> <span class="token function">hasTasks</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">case</span> SelectStrategy<span class="token punctuation">.</span>CONTINUE<span class="token operator">:</span>                    <span class="token keyword">continue</span><span class="token punctuation">;</span>                <span class="token keyword">case</span> SelectStrategy<span class="token punctuation">.</span>SELECT<span class="token operator">:</span>                    <span class="token comment" spellcheck="true">// 轮询IO事件，等待事件的发生</span>                    <span class="token function">select</span><span class="token punctuation">(</span>wakenUp<span class="token punctuation">.</span><span class="token function">getAndSet</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>wakenUp<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        selector<span class="token punctuation">.</span><span class="token function">wakeup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                    <span class="token comment" spellcheck="true">// fall through</span>                <span class="token keyword">default</span><span class="token operator">:</span>            <span class="token punctuation">}</span>            cancelledKeys <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            needsToSelectAgain <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token keyword">final</span> <span class="token keyword">int</span> ioRatio <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>ioRatio<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 如果ioRatio==100 就调用第一个 processSelectedKeys();  否则就调用第二个</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>ioRatio <span class="token operator">==</span> <span class="token number">100</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">try</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">// 处理感兴趣事件</span>                    <span class="token function">processSelectedKeys</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">// Ensure we always run tasks.</span>                    <span class="token comment" spellcheck="true">// 用于处理本eventLoop外的线程 扔到taskQueue中的任务</span>                    <span class="token function">runAllTasks</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 因为ioRatio默认是50 , 所以第一次走else</span>                <span class="token keyword">final</span> <span class="token keyword">long</span> ioStartTime <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">try</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">// 处理IO事件</span>                    <span class="token function">processSelectedKeys</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">// Ensure we always run tasks.</span>                    <span class="token comment" spellcheck="true">// 根据处理IO事件耗时 ,控制 下面的runAllTasks执行任务不能超过 ioTime 时间</span>                    <span class="token keyword">final</span> <span class="token keyword">long</span> ioTime <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> ioStartTime<span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">// 这里面有聚合任务的逻辑</span>                    <span class="token function">runAllTasks</span><span class="token punctuation">(</span>ioTime <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token number">100</span> <span class="token operator">-</span> ioRatio<span class="token punctuation">)</span> <span class="token operator">/</span> ioRatio<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> t<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">handleLoopException</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// Always handle shutdown even if the loop processing threw an exception.</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isShuttingDown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">closeAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">confirmShutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">return</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> t<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">handleLoopException</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 基于deadline的任务穿插处理逻辑 * * 根据当前时间计算出本次for()的最迟截止时间, 也就是他的deadline * 判断1 如果超过了 截止时间,selector.selectNow(); 直接退出 * 判断2 如果任务队列中出现了新的任务 selector.selectNow(); 直接退出 * 经过了上面12两次判断后, netty 进行阻塞式select(time) ,默认是1秒这时可会会出现空轮询的Bug * 判断3 如果经过阻塞式的轮询之后,出现的感兴趣的事件,或者任务队列又有新任务了,或者定时任务中有新任务了,或者被外部线程唤醒了 都直接退出循环 * 如果前面都没出问题,最后检验是否出现了JDK空轮询的BUG */</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">select</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> oldWakenUp<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>    Selector selector <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>selector<span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> selectCnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">long</span> currentTimeNanos <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// todo 计算出估算的截止时间,  意思是, select()操作不能超过selectDeadLineNanos这个时间, 不让它一直耗着,外面也可能有任务等着当前线程处理</span>        <span class="token keyword">long</span> selectDeadLineNanos <span class="token operator">=</span> currentTimeNanos <span class="token operator">+</span> <span class="token function">delayNanos</span><span class="token punctuation">(</span>currentTimeNanos<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// todo 计算超时时间</span>            <span class="token keyword">long</span> timeoutMillis <span class="token operator">=</span> <span class="token punctuation">(</span>selectDeadLineNanos <span class="token operator">-</span> currentTimeNanos <span class="token operator">+</span> 500000L<span class="token punctuation">)</span> <span class="token operator">/</span> 1000000L<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>timeoutMillis <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// todo 如果超时了 , 并且selectCnt==0 , 就进行非阻塞的 select() , break, 跳出for循环</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>selectCnt <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    selector<span class="token punctuation">.</span><span class="token function">selectNow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    selectCnt <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">// todo 判断任务队列中时候还有别的任务, 如果有任务的话, 进入代码块, 非阻塞的select() 并且 break; 跳出循环</span>            <span class="token comment" spellcheck="true">// todo 通过cas 线程安全的把 wakenUp设置成true表示退出select()方法, 已进入时,我们设置oldWakenUp是false</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">hasTasks</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> wakenUp<span class="token punctuation">.</span><span class="token function">compareAndSet</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                selector<span class="token punctuation">.</span><span class="token function">selectNow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                selectCnt <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">///todo ----------- 如上部分代码, 是 select()的deadLine及任务穿插处理逻辑----------</span>            <span class="token comment" spellcheck="true">///todo ----------- 如下, 是 阻塞式的select() ---------------------------------</span>            <span class="token comment" spellcheck="true">// todo  上面设置的超时时间没到,而且任务为空,进行阻塞式的 select() , timeoutMillis 默认1</span>            <span class="token comment" spellcheck="true">// todo netty任务,现在可以放心大胆的 阻塞1秒去轮询 channel连接上是否发生的 selector感性的事件</span>            <span class="token keyword">int</span> selectedKeys <span class="token operator">=</span> selector<span class="token punctuation">.</span><span class="token function">select</span><span class="token punctuation">(</span>timeoutMillis<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// todo 表示当前已经轮询了SelectCnt次了</span>            selectCnt <span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// todo  阻塞完成轮询后,马上进一步判断 只要满足下面的任意一条. 也将退出无限for循环, select()</span>            <span class="token comment" spellcheck="true">// todo  selectedKeys != 0      表示轮询到了事件</span>            <span class="token comment" spellcheck="true">// todo  oldWakenUp             当前的操作是否需要唤醒</span>            <span class="token comment" spellcheck="true">// todo  wakenUp.get()          可能被外部线程唤醒</span>            <span class="token comment" spellcheck="true">// todo  hasTasks()             任务队列中又有新任务了</span>            <span class="token comment" spellcheck="true">// todo   hasScheduledTasks()   当时定时任务队列里面也有任务</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>selectedKeys <span class="token operator">!=</span> <span class="token number">0</span> <span class="token operator">||</span> oldWakenUp <span class="token operator">||</span> wakenUp<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token function">hasTasks</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token function">hasScheduledTasks</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// - Selected something,</span>                <span class="token comment" spellcheck="true">// - waken up by user, or</span>                <span class="token comment" spellcheck="true">// - the task queue has a pending task.</span>                <span class="token comment" spellcheck="true">// - a scheduled task is ready for processing</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">// todo ------------ 如上, 是 阻塞式的select() -----------------------------------------------------</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">interrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>logger<span class="token punctuation">.</span><span class="token function">isDebugEnabled</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    logger<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">"Selector.select() returned prematurely because "</span> <span class="token operator">+</span>                            <span class="token string">"Thread.currentThread().interrupt() was called. Use "</span> <span class="token operator">+</span>                            <span class="token string">"NioEventLoop.shutdownGracefully() to shutdown the NioEventLoop."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                selectCnt <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">// todo 每次执行到这里就说明,已经进行了一次阻塞式操作 ,并且还没有监听到任何感兴趣的事件,也没有新的任务添加到队列, 记录当前的时间</span>            <span class="token keyword">long</span> time <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// todo 如果  当前的时间 - 超时时间 >= 开始时间   把 selectCnt设置为1 , 表明已经进行了一次阻塞式操作</span>            <span class="token comment" spellcheck="true">// todo 每次for循环都会判断, 当前时间 currentTimeNanos 不能超过预订的超时时间 timeoutMillis</span>            <span class="token comment" spellcheck="true">// todo 但是,现在的情况是, 虽然已经进行了一次 时长为timeoutMillis时间的阻塞式select了,</span>            <span class="token comment" spellcheck="true">// todo 然而, 我执行到当前代码的 时间 - 开始的时间 >= 超时的时间</span>            <span class="token comment" spellcheck="true">// todo 但是,如果 当前时间- 超时时间&lt; 开始时间, 也就是说,并没有阻塞select, 而是立即返回了, 就表明这是一次空轮询</span>            <span class="token comment" spellcheck="true">// todo 而每次轮询   selectCnt ++;  于是有了下面的判断,</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>time <span class="token operator">-</span> TimeUnit<span class="token punctuation">.</span>MILLISECONDS<span class="token punctuation">.</span><span class="token function">toNanos</span><span class="token punctuation">(</span>timeoutMillis<span class="token punctuation">)</span> <span class="token operator">>=</span> currentTimeNanos<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// timeoutMillis elapsed without anything selected.</span>                selectCnt <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>SELECTOR_AUTO_REBUILD_THRESHOLD <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span>                    <span class="token comment" spellcheck="true">// todo  selectCnt如果大于 512 表示cpu确实在空轮询, 于是rebuild Selector</span>                    selectCnt <span class="token operator">>=</span> SELECTOR_AUTO_REBUILD_THRESHOLD<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// The selector returned prematurely many times in a row.</span>                <span class="token comment" spellcheck="true">// Rebuild the selector to work around the problem.</span>                logger<span class="token punctuation">.</span><span class="token function">warn</span><span class="token punctuation">(</span>                        <span class="token string">"Selector.select() returned prematurely {} times in a row; rebuilding Selector {}."</span><span class="token punctuation">,</span>                        selectCnt<span class="token punctuation">,</span> selector<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// todo 它的逻辑创建一个新的selectKey , 把老的Selector上面的key注册进这个新的selector上面 , 进入查看</span>                <span class="token function">rebuildSelector</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                selector <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>selector<span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// Select again to populate selectedKeys.</span>                <span class="token comment" spellcheck="true">// todo 解决了Select空轮询的bug</span>                selector<span class="token punctuation">.</span><span class="token function">selectNow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                selectCnt <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            currentTimeNanos <span class="token operator">=</span> time<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>selectCnt <span class="token operator">></span> MIN_PREMATURE_SELECTOR_RETURNS<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>logger<span class="token punctuation">.</span><span class="token function">isDebugEnabled</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                logger<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">"Selector.select() returned prematurely {} times in a row for Selector {}."</span><span class="token punctuation">,</span>                        selectCnt <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> selector<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">CancelledKeyException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>logger<span class="token punctuation">.</span><span class="token function">isDebugEnabled</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            logger<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span>CancelledKeyException<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getSimpleName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" raised by a Selector {} - JDK bug?"</span><span class="token punctuation">,</span>                    selector<span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// Harmless exception - log anyway</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>NioEventLoop主要做三件事：</p><ul><li>轮询IO事件</li><li>处理IO事件</li><li>处理非IO任务</li></ul><h4 id="什么是Jdk的Selector空轮询"><a href="#什么是Jdk的Selector空轮询" class="headerlink" title="什么是Jdk的Selector空轮询"></a>什么是Jdk的Selector空轮询</h4><p>我们可以看到,上面的<code>run()</code>方法,经过两次判断后进入了指定时长的阻塞式轮询,而我们常说的空轮询bug,指的就是本来该阻塞住轮询,但是却直接返回了, 在这个死循环中,它的畅通执行很可能使得CPU的使用率飙升, 于是把这种情况说是jdk的selector的空轮询的bug。</p><p>在NIO中通过Selector的轮询当前是否有IO事件，根据JDK NIO api描述，Selector的select方法会一直阻塞，直到IO事件达到或超时，但是在Linux平台上这里有时会出现问题，在某些场景下select方法会直接返回，即使没有超时并且也没有IO事件到达，这就是著名的epoll bug，这是一个比较严重的bug，它会导致线程陷入死循环，会让CPU飙到100%，极大地影响系统的可靠性，到目前为止，JDK都没有完全解决这个问题。</p><p>但是Netty有效的规避了这个问题，经过实践证明，epoll bug已Netty框架解决，Netty的处理方式是这样的：</p><p>记录select空转的次数，定义一个阀值，这个阀值默认是512，可以在应用层通过设置系统属性io.netty.selectorAutoRebuildThreshold传入，当空转的次数超过了这个阀值，重新构建新Selector，将老Selector上注册的Channel转移到新建的Selector上，关闭老Selector，用新的Selector代替老Selector。</p><h4 id="Netty-如何解决了Jdk的Selector空轮询bug"><a href="#Netty-如何解决了Jdk的Selector空轮询bug" class="headerlink" title="Netty 如何解决了Jdk的Selector空轮询bug?"></a>Netty 如何解决了Jdk的Selector空轮询bug?</h4><p>一个分支语句 <code>if(){}else{}</code> , 首先他记录下,现在执行判断时的时间, 然后用下面的公式判断</p><pre class=" language-java"><code class="language-java">当前的时间t1 <span class="token operator">-</span> 预订的deadLine截止时间t2  <span class="token operator">>=</span> 开始进入<span class="token keyword">for</span>循环的时间t3</code></pre><p>我们想, 如果说,上面的阻塞式<code>select(t2)</code>没出现任何问题,那么 我现在来检验是否出现了空轮询是时间t1 = t2+执行其他代码的时间, 如果是这样, 上面的等式肯定是成立的, 等式成立说没bug, 顺道把<code>selectCnt = 1;</code></p><p>但是如果出现了空轮询,<code>select(t2)</code> 并没有阻塞,而是之间返回了, 那么现在的时间 t1 = 0+执行其他代码的时间, 这时的t1相对于上一个没有bug的大小,明显少了一个t2, 这时再用t1-t2 都可能是一个负数, 等式不成立,就进入了else的代码块, netty接着判断,是否是真的在空轮询, 如果说循环的次数达到了512次, netty就确定真的出现了空轮询, 于是netty<code>rebuild()</code>Selector ,从新开启一个Selector, 循环老的Selector上面的上面的注册的时间,重新注册进新的 Selector上,用这个中替换Selector的方法,解决了空轮询的bug。</p>]]></content>
      
      
      <categories>
          
          <category> Netty </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 并发 </tag>
            
            <tag> Netty </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java之ThreadLocal浅析</title>
      <link href="/2019/10/22/Java%E4%B9%8BThreadLocal%E6%B5%85%E6%9E%90/"/>
      <url>/2019/10/22/Java%E4%B9%8BThreadLocal%E6%B5%85%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="Java之ThreadLocal浅析"><a href="#Java之ThreadLocal浅析" class="headerlink" title="Java之ThreadLocal浅析"></a>Java之ThreadLocal浅析</h1><h3 id="一、ThreadLocal介绍"><a href="#一、ThreadLocal介绍" class="headerlink" title="一、ThreadLocal介绍"></a>一、ThreadLocal介绍</h3><pre class=" language-xml"><code class="language-xml">    ThreadLocal 又名线程局部变量 ，是 Java 中一种较为特殊的线程绑定机制，可以为每一个使用该变量的线程都提供一个变量值的副本，并且每一个线程都可以独立地改变自己的副本，而不会与其它线程的副本发生冲突。一般而言，通过 ThreadLocal 存取的数据总是与当前线程相关，也就是说，JVM 为每个运行的线程绑定了私有的本地实例存取空间，从而为多线程环境常出现的并发访问问题提供了一种隔离机制 。    如果一段代码中所需要的数据必须与其他代码共享，那就看看这些共享数据的代码能否保证在同一个线程中执行？如果能保证，我们就可以把共享数据的可见范围限制在同一个线程之内，这样，无须同步也能保证线程之间不出现数据争用的问题。也就是说，如果一个某个变量要被某个线程 独享，那么我们就可以通过ThreadLocal来实现线程本地存储功能。    从JDK中理解其特点：    （1）每个线程都有关于该 ThreadLocal变量 的私有值    每个线程都有一个独立于其他线程的上下文来保存这个变量的值，并且对其他线程是不可见的    。    （2）独立于变量的初始值     ThreadLocal 可以给定一个初始值，这样每个线程就会获得这个初始化值的一个拷贝，并且每个线程对这个值的修改对其他线程是不可见的。    （3）将某个类的状态与线程相关联     我们从JDK中对ThreadLocal的描述中可以看出，ThreadLocal的一个重要作用是就是将类的状态与线程关联起来，这个时候通常的解决方案就是在这个类中定义一个 private static ThreadLocal 实例。</code></pre><h3 id="ThreadLocal应用"><a href="#ThreadLocal应用" class="headerlink" title="ThreadLocal应用"></a>ThreadLocal应用</h3><h3 id="ThreadLocal源码剖析"><a href="#ThreadLocal源码剖析" class="headerlink" title="ThreadLocal源码剖析"></a>ThreadLocal源码剖析</h3><h3 id="Thread同步机制的比较（摘自CSDN）"><a href="#Thread同步机制的比较（摘自CSDN）" class="headerlink" title="Thread同步机制的比较（摘自CSDN）"></a>Thread同步机制的比较（摘自<a href="http://blog.csdn.net/lufeng20/article/details/24314381" target="_blank" rel="noopener">CSDN</a>）</h3><pre class=" language-xml"><code class="language-xml">    ThreadLocal和线程同步机制相比有什么优势呢？ThreadLocal和线程同步机制都是为了解决多线程中相同变量的访问冲突问题。    在同步机制中，通过对象的锁机制保证同一时间只有一个线程访问变量。这时该变量是多个线程共享的，使用同步机制要求程序慎密地分析什么时候对变量进行读写，什么时候需要锁定某个对象，什么时候释放对象锁等繁杂的问题，程序设计和编写难度相对较大。    而ThreadLocal则从另一个角度来解决多线程的并发访问。ThreadLocal会为每一个线程提供一个独立的变量副本，从而隔离了多个线程对数据的访问冲突。因为每一个线程都拥有自己的变量副本，从而也就没有必要对该变量进行同步了。ThreadLocal提供了线程安全的共享对象，在编写多线程代码时，可以把不安全的变量封装进ThreadLocal。    由于ThreadLocal中可以持有任何类型的对象，低版本JDK所提供的get()返回的是Object对象，需要强制类型转换。但JDK 5.0通过泛型很好的解决了这个问题，在一定程度地简化ThreadLocal的使用，代码清单 9 2就使用了JDK 5.0新的ThreadLocal<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>T</span><span class="token punctuation">></span></span>版本。    概括起来说，对于多线程资源共享的问题，同步机制采用了“以时间换空间”的方式，而ThreadLocal采用了“以空间换时间”的方式。前者仅提供一份变量，让不同的线程排队访问，而后者为每一个线程都提供了一份变量，因此可以同时访问而互不影响。    Spring使用ThreadLocal解决线程安全问题我们知道在一般情况下，只有无状态的Bean才可以在多线程环境下共享，在Spring中，绝大部分Bean都可以声明为singleton作用域。就是因为Spring对一些Bean（如RequestContextHolder、TransactionSynchronizationManager、LocaleContextHolder等）中非线程安全状态采用ThreadLocal进行处理，让它们也成为线程安全的状态，因为有状态的Bean就可以在多线程中共享了。    一般的Web应用划分为展现层、服务层和持久层三个层次，在不同的层中编写对应的逻辑，下层通过接口向上层开放功能调用。在一般情况下，从接收请求到返回响应所经过的所有程序调用都同属于一个线程，同一线程贯通三层这样你就可以根据需要，将一些非线程安全的变量以ThreadLocal存放，在同一次请求响应的调用线程中，所有关联的对象引用到的都是同一个变量。</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 多线程 </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java之线程池探索</title>
      <link href="/2019/10/20/Java%E4%B9%8B%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%8E%A2%E7%B4%A2/"/>
      <url>/2019/10/20/Java%E4%B9%8B%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%8E%A2%E7%B4%A2/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 多线程 </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hello world</title>
      <link href="/2019/09/07/hello-world/"/>
      <url>/2019/09/07/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post（在博客根目录下）"><a href="#Create-a-new-post（在博客根目录下）" class="headerlink" title="Create a new post（在博客根目录下）"></a>Create a new post（在博客根目录下）</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p><p>**</p><h3 id="常见命令"><a href="#常见命令" class="headerlink" title="常见命令"></a>常见命令</h3><pre class=" language-java"><code class="language-java">hexo <span class="token keyword">new</span> <span class="token string">"postName"</span> #新建文章hexo <span class="token keyword">new</span> <span class="token class-name">page</span> <span class="token string">"pageName"</span> #新建页面hexo generate #生成静态页面至<span class="token keyword">public</span>目录hexo server #开启预览访问端口（默认端口<span class="token number">4000</span>，<span class="token string">'ctrl + c'</span>关闭server）hexo deploy #部署到GitHubhexo help  # 查看帮助hexo version  #查看Hexo的版本缩写：hexo n <span class="token operator">==</span> hexo <span class="token keyword">new</span><span class="token class-name">hexo</span> g <span class="token operator">==</span> hexo generatehexo s <span class="token operator">==</span> hexo serverhexo d <span class="token operator">==</span> hexo deploy组合命令：hexo s <span class="token operator">-</span>g #生成并本地预览hexo d <span class="token operator">-</span>g #生成并上传</code></pre><h3 id="hexo-备份方式："><a href="#hexo-备份方式：" class="headerlink" title="hexo 备份方式："></a>hexo 备份方式：</h3><p>​    1、github的hexo仓库创建hexo分支，将源文件上传至这个分支；</p><p>​    2、在另外电脑也可同步操作这个博客库，git clone 博客库，在hexo分支开发，先执行npm install……</p>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Typora </tag>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
